<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="简介  本文主要是参考了《Redis核心技术与实战》的基础篇。  本文需要搞明白的问题有：  基本架构：一个键值数据库包含什么？ 数据结构：快速的Redis有哪些慢操作？ 高性能IO模型：为什么单线程Redis能那么快？ AOF日志&amp;RDB快照：宕机了，Redis如何避免数据丢失，如何实现数据恢复？ 数据同步：主从库如何实现数据一致？ 哨兵机制&amp;哨兵集群：主库挂了，如何不间断服务？">
<meta property="og:type" content="article">
<meta property="og:title" content="初识redis">
<meta property="og:url" content="http://example.com/2022/06/28/Getting-to-know-redis/index.html">
<meta property="og:site_name" content="复方汤剂">
<meta property="og:description" content="简介  本文主要是参考了《Redis核心技术与实战》的基础篇。  本文需要搞明白的问题有：  基本架构：一个键值数据库包含什么？ 数据结构：快速的Redis有哪些慢操作？ 高性能IO模型：为什么单线程Redis能那么快？ AOF日志&amp;RDB快照：宕机了，Redis如何避免数据丢失，如何实现数据恢复？ 数据同步：主从库如何实现数据一致？ 哨兵机制&amp;哨兵集群：主库挂了，如何不间断服务？">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2022/06/28/Getting-to-know-redis/simple_kv_structure.png">
<meta property="og:image" content="http://example.com/2022/06/28/Getting-to-know-redis/from_simple_kv_to_redis.png">
<meta property="og:image" content="http://example.com/2022/06/28/Getting-to-know-redis/data_structure.png">
<meta property="og:image" content="http://example.com/2022/06/28/Getting-to-know-redis/global_hash_table.png">
<meta property="og:image" content="http://example.com/2022/06/28/Getting-to-know-redis/link_hash.png">
<meta property="og:image" content="http://example.com/2022/06/28/Getting-to-know-redis/rehash.png">
<meta property="og:image" content="http://example.com/2022/06/28/Getting-to-know-redis/zip_list.png">
<meta property="og:image" content="http://example.com/2022/06/28/Getting-to-know-redis/jump_list.png">
<meta property="og:image" content="http://example.com/2022/06/28/Getting-to-know-redis/redis_io_multiplex.png">
<meta property="og:image" content="http://example.com/2022/06/28/Getting-to-know-redis/aof_rewrite.png">
<meta property="og:image" content="http://example.com/2022/06/28/Getting-to-know-redis/rdb_write.png">
<meta property="og:image" content="http://example.com/2022/06/28/Getting-to-know-redis/aof_cooperate_with_rdb.png">
<meta property="og:image" content="http://example.com/2022/06/28/Getting-to-know-redis/master_slave_sync.png">
<meta property="og:image" content="http://example.com/2022/06/28/Getting-to-know-redis/cascade.png">
<meta property="og:image" content="http://example.com/2022/06/28/Getting-to-know-redis/network_off_solution.png">
<meta property="article:published_time" content="2022-06-28T10:28:51.000Z">
<meta property="article:modified_time" content="2022-07-10T10:35:04.835Z">
<meta property="article:author" content="Ran">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/06/28/Getting-to-know-redis/simple_kv_structure.png">

<link rel="canonical" href="http://example.com/2022/06/28/Getting-to-know-redis/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>初识redis | 复方汤剂</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="复方汤剂" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">复方汤剂</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/28/Getting-to-know-redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Ran">
      <meta itemprop="description" content="talk is cheap. 知行合一">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="复方汤剂">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          初识redis
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-06-28 18:28:51" itemprop="dateCreated datePublished" datetime="2022-06-28T18:28:51+08:00">2022-06-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-07-10 18:35:04" itemprop="dateModified" datetime="2022-07-10T18:35:04+08:00">2022-07-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="Symbols count in article">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">Symbols count in article: </span>
              <span>14k</span>
            </span>
            <span class="post-meta-item" title="Reading time">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">Reading time &asymp;</span>
              <span>13 mins.</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote>
<p> 本文主要是参考了《Redis核心技术与实战》的基础篇。</p>
</blockquote>
<p>本文需要搞明白的问题有：</p>
<ul>
<li>基本架构：一个键值数据库包含什么？</li>
<li>数据结构：快速的Redis有哪些慢操作？</li>
<li>高性能IO模型：为什么单线程Redis能那么快？</li>
<li>AOF日志&amp;RDB快照：宕机了，Redis如何避免数据丢失，如何实现数据恢复？</li>
<li>数据同步：主从库如何实现数据一致？</li>
<li>哨兵机制&amp;哨兵集群：主库挂了，如何不间断服务？哨兵挂了，主从库怎么切？</li>
<li>切片集群：数据增多了，是该加内存还是加实例？</li>
</ul>
<span id="more"></span>

<h1 id="基本架构：一个键值数据库包含什么？"><a href="#基本架构：一个键值数据库包含什么？" class="headerlink" title="基本架构：一个键值数据库包含什么？"></a>基本架构：一个键值数据库包含什么？</h1><p>Redis是一个键值数据库。</p>
<p>以下以一个简单的数值数据库SimpleKV为例，从架构方面来介绍设计一个键值数据库应当考虑哪些问题。</p>
<h2 id="存什么数据-amp-做什么操作"><a href="#存什么数据-amp-做什么操作" class="headerlink" title="存什么数据 &amp; 做什么操作"></a>存什么数据 &amp; 做什么操作</h2><h3 id="存什么数据"><a href="#存什么数据" class="headerlink" title="存什么数据"></a>存什么数据</h3><p>对于键值数据库而言，基本的数据模型是key-value模型。不同键值数据库支持的key类型一般差异不大，而value类型则有较大差别。我们在对键值数据库进行选型时，一个重要的考虑因素是<strong>它支持的value类型</strong>。例如，Memcached支持的value类型仅为String类型，而Redis支持的value类型包括了String、哈希表、列表、集合等。</p>
<p>从使用的角度来说，不同value类型的实现，不仅可以支撑不同业务的数据需求，而且也隐含着不同数据结构在性能、空间效率等方面的差异，从而导致不同的value操作之间存在着差异。</p>
<h3 id="做什么操作"><a href="#做什么操作" class="headerlink" title="做什么操作"></a>做什么操作</h3><p>对于一个数据库，基本操作无外乎增删改查。</p>
<ul>
<li>SET：新写入或更新一个key-value对；</li>
<li>GET：根据一个key读取相应的value值；</li>
<li>DELETE：根据一个key删除整个key-value对。</li>
</ul>
<p>在实际的业务场景中，我们经常会碰到这种情况：查询一个用户在一段时间内的访问记录。这种操作在键值数据库中属于SCAN操作，即<strong>根据一段key的范围返回相应的value值</strong>。因此，<strong>PUT&#x2F;GET&#x2F;DELETE&#x2F;SCAN是一个键值数据库的基本操作集合</strong>。</p>
<h2 id="键值对保存在哪？"><a href="#键值对保存在哪？" class="headerlink" title="键值对保存在哪？"></a>键值对保存在哪？</h2><p><strong>键值对保存在内存还是外存</strong>？</p>
<ul>
<li><p>内存优缺：读写很快。潜在的风险是一旦掉电，所有的数据都会丢失。</p>
</li>
<li><p>外存优缺：可避免数据丢失，但读写慢。</p>
</li>
</ul>
<p><strong>如何进行设计选择，我们通常需要考虑键值数据库的主要应用场景</strong>。比如，缓存场景下的数据需要能快速访问但允许丢失，那么，用于此场景的键值数据库通常采用内存保存键值数据。Memcached和Redis都是属于内存键值数据库。</p>
<p>为了和Redis保持一致，我们的SimpleKV就采用内存保存键值数据。</p>
<h2 id="如何定位键值对的位置"><a href="#如何定位键值对的位置" class="headerlink" title="如何定位键值对的位置"></a>如何定位键值对的位置</h2><p>当SimpleKV解析了客户端发来的请求，知道了要进行的键值对操作，此时，SimpleKV需要查找所要操作的键值对是否存在，这依赖于键值数据库的索引模块。<strong>索引的作用是让键值数据库根据key找到相应value的存储位置，进而执行操作</strong>。</p>
<p>内存键值数据库（例如Redis）采用哈希表作为索引，很大一部分原因在于，其键值数据基本都是保存在内存中的，而内存的高性能随机访问特性可以很好地与哈希表O(1)的操作复杂度相匹配。</p>
<p>对于Redis而言，它的value支持多种类型，当我们通过索引找到一个key所对应的value后，仍然需要从value的复杂结构（例如集合和列表）中进一步找到我们实际需要的数据，这个操作的效率本身就依赖于它们的实现结构。</p>
<p>对于PUT和DELETE两种操作来说，除了新写入和删除键值对，还需要分配和释放内存。这就涉及到SimpleKV的存储模块了。</p>
<h2 id="如何实现重启后快速提供服务"><a href="#如何实现重启后快速提供服务" class="headerlink" title="如何实现重启后快速提供服务"></a>如何实现重启后快速提供服务</h2><p>我们希望SimpleKV重启后能快速重新提供服务，所以，需要在SimpleKV的存储模块中增加持久化功能。</p>
<p>SimpleKV可以直接采用了文件形式，将键值数据通过调用本地文件系统的操作接口保存在磁盘上。此时，SimpleKV只需要考虑何时将内存中的键值数据保存到文件中，就可以了。</p>
<p>一种方式是，对于每一个键值对，SimpleKV都对其进行落盘保存，这虽然让SimpleKV的数据更加可靠，但是，因为每次都要写盘，SimpleKV的性能会受到很大影响。</p>
<p>另一种方式是，SimpleKV只是周期性地把内存中的键值数据保存到文件中，这样可以避免频繁写盘操作的性能影响。但是，一个潜在的代价是SimpleKV的数据仍然有丢失的风险。</p>
<p>和SimpleKV一样，Redis也提供了持久化功能。不过，为了适应不同的业务场景，Redis为持久化提供了诸多的执行机制和优化改进。</p>
<h2 id="基本内部架构"><a href="#基本内部架构" class="headerlink" title="基本内部架构"></a>基本内部架构</h2><p>一个键值数据库包括了<strong>访问框架、索引模块、操作模块和存储模块</strong>四部分。</p>
<img src="/2022/06/28/Getting-to-know-redis/simple_kv_structure.png" class="">

<p>访问模式通常有两种：一种是<strong>通过函数库调用的方式供外部应用使用</strong>，比如，上图中的libsimplekv.so，就是以动态链接库的形式链接到我们自己的程序中，提供键值存储功能；另一种是<strong>通过网络框架以Socket通信的形式对外提供键值对操作</strong>，这种形式可以提供广泛的键值存储服务。在上图中，我们可以看到，网络框架中包括Socket Server和协议解析。</p>
<p>Memcached和Redis是通过网络框架访问。</p>
<p>采用网络访问模式会存在这样的问题：网络连接的处理、网络请求的解析，以及数据存取的处理，是用一个线程、多个线程，还是多个进程来交互处理呢？该如何进行设计和取舍呢？</p>
<p>如果一个线程既要处理网络连接、解析请求，又要完成数据存取，一旦某一步操作发生阻塞，整个线程就会阻塞住，这就降低了系统响应速度。如果我们采用不同线程处理不同操作，那么，某个线程被阻塞时，其他线程还能正常运行。但是，不同线程间如果需要访问共享资源，那又会产生线程竞争，也会影响系统效率。</p>
<h2 id="从SimpleKV到Redis"><a href="#从SimpleKV到Redis" class="headerlink" title="从SimpleKV到Redis"></a>从SimpleKV到Redis</h2><img src="/2022/06/28/Getting-to-know-redis/from_simple_kv_to_redis.png" class="">

<p>从这张对比图中，我们可以看到，从SimpleKV演进到Redis，有以下几个重要变化：</p>
<ul>
<li>Redis主要通过网络框架进行访问，而不再是动态库了，这也使得Redis可以作为一个基础性的网络服务进行访问，扩大了Redis的应用范围。</li>
<li>Redis数据模型中的value类型很丰富，因此也带来了更多的操作接口。</li>
<li>Redis的持久化模块能支持两种方式：日志（AOF）和快照（RDB），这两种持久化方式具有不同的优劣势，影响到Redis的访问性能和可靠性。</li>
<li>SimpleKV是个简单的单机键值数据库，但是，Redis支持高可靠集群和高可扩展集群，因此，Redis中包含了相应的集群功能支撑模块。</li>
</ul>
<h1 id="数据结构：快速的Redis由哪些慢操作？"><a href="#数据结构：快速的Redis由哪些慢操作？" class="headerlink" title="数据结构：快速的Redis由哪些慢操作？"></a>数据结构：快速的Redis由哪些慢操作？</h1><p>Redis接收到一个键值对操作后，能以<strong>微秒级别</strong>的速度找到数据，并快速完成操作。快的原因有两方面：</p>
<ul>
<li>内存数据库，所有操作都在内存中完成。</li>
<li>数据结构设计得好。</li>
</ul>
<p>Redis数据类型有五种：String（字符串）、List（列表）、Hash（哈希）、Set（集合）和Sorted Set（有序集合）。</p>
<p>底层数据结构一共有6种，分别是简单动态字符串、双向链表、压缩列表、哈希表、跳表和整数数组。</p>
<p>它们和数据类型的对应关系如下图所示：</p>
<img src="/2022/06/28/Getting-to-know-redis/data_structure.png" class="">

<p>String类型的底层实现只有一种数据结构，也就是简单动态字符串。而List、Hash、Set和Sorted Set这四种数据类型，都有两种底层实现结构。通常情况下，我们会把这四种类型称为集合类型，它们的特点是<strong>一个键对应了一个集合的数据</strong>。</p>
<h2 id="键值对的结构"><a href="#键值对的结构" class="headerlink" title="键值对的结构"></a>键值对的结构</h2><p>Redis使用了一个哈希表来保存所有键值对。</p>
<p>一个哈希表，其实就是一个数组，数组的每个元素称为一个哈希桶，每个哈希桶中保存了键值对数据。哈希桶中的元素保存的并不是值本身，而是指向具体值的指针。</p>
<img src="/2022/06/28/Getting-to-know-redis/global_hash_table.png" class="">

<p>我们只需要计算键的哈希值，就可以知道它所对应的哈希桶位置，然后就可以访问相应的entry元素。时间复杂度为O(1)。</p>
<p>当我们往Redis中写入大量数据后，就可能发现操作有时候会突然变慢了，原因在于：<strong>哈希表的冲突问题和rehash可能带来的操作阻塞。</strong></p>
<h2 id="哈希表的冲突和rehash"><a href="#哈希表的冲突和rehash" class="headerlink" title="哈希表的冲突和rehash"></a>哈希表的冲突和rehash</h2><p>哈希冲突：两个key正好落在了同一个哈希桶中。</p>
<p>Redis解决哈希冲突的方式，就是链式哈希，即<strong>同一个哈希桶中的多个元素用一个链表来保存，它们之间依次用指针连接</strong>。如下图所示。</p>
<img src="/2022/06/28/Getting-to-know-redis/link_hash.png" class="">

<p>但存在一个问题：哈希冲突链上的元素只能通过指针逐一查找再操作。如果冲突过多，某些哈希冲突链过长，那么这个链上的元素查找耗时也会变长，效率会降低。对于追求“快”的Redis来说，这是不太能接受的。</p>
<p>所以，Redis会对哈希表做rehash操作。rehash也就是增加现有的哈希桶数量，让逐渐增多的entry元素能在更多的桶之间分散保存，减少单个桶中的元素数量，从而减少单个桶中的冲突。</p>
<p>为了使rehash操作更高效，Redis默认使用了两个全局哈希表：哈希表1和哈希表2。一开始，当你刚插入数据时，默认使用哈希表1，此时的哈希表2并没有被分配空间。随着数据逐步增多，Redis开始执行rehash，步骤有三步：</p>
<ul>
<li>给哈希表2分配更大的空间，例如是当前哈希表1大小的两倍；</li>
<li>把哈希表1中的数据重新映射并拷贝到哈希表2中；</li>
<li>释放哈希表1的空间。</li>
</ul>
<p>到此，我们就可以从哈希表1切换到哈希表2，用增大的哈希表2保存更多数据，而原来的哈希表1留作下一次rehash扩容备用。</p>
<p>第二步涉及大量的数据拷贝，如果一次性把哈希表1中的数据都迁移完，会造成Redis线程阻塞，无法服务其他请求。为了避免这个问题，Redis采用了<strong>渐进式rehash</strong>。</p>
<p>渐进式rehash：在第二步拷贝数据时，Redis仍然正常处理客户端请求，每处理一个请求时，从哈希表1中的第一个索引位置开始，顺带着将这个索引位置上的所有entries拷贝到哈希表2中；等处理下一个请求时，再顺带拷贝哈希表1中的下一个索引位置的entries。如图所示。</p>
<p>这样一来，rehash把一次性大量拷贝的开销，分摊到了多次处理请求的过程中，避免了耗时操作，保证了数据的快速访问。</p>
<img src="/2022/06/28/Getting-to-know-redis/rehash.png" class="">

<h2 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h2><p>压缩列表实际上类似于一个数组，数组中的每一个元素都对应保存一个数据。和数组不同的是，压缩列表在表头有三个字段zlbytes、zltail和zllen，分别表示列表长度、列表尾的偏移量和列表中的entry个数；压缩列表在表尾还有一个zlend，表示列表结束。</p>
<img src="/2022/06/28/Getting-to-know-redis/zip_list.png" class="">

<p>在压缩列表中，如果我们要查找定位第一个元素和最后一个元素，可以通过表头三个字段的长度直接定位，复杂度是O(1)。而查找其他元素时，就没有这么高效了，只能逐个查找，此时的复杂度就是O(N)了。</p>
<h2 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h2><p>有序链表只能逐一查找元素，导致操作起来非常缓慢，于是就出现了跳表。具体来说，跳表在链表的基础上，<strong>增加了多级索引，通过索引位置的几个跳转，实现数据的快速定位</strong>。</p>
<img src="/2022/06/28/Getting-to-know-redis/jump_list.png" class="">

<p>为了提高查找速度，我们来增加一级索引：从第一个元素开始，每两个元素选一个出来作为索引。这些索引再通过指针指向原始的链表。例如，从前两个元素中抽取元素1作为一级索引，从第三、四个元素中抽取元素11作为一级索引。此时，我们只需要4次查找就能定位到元素33了。</p>
<p>如果我们还想再快，可以再增加二级索引：从一级索引中，再抽取部分元素作为二级索引。例如，从一级索引中抽取1、27、100作为二级索引，二级索引指向一级索引。这样，我们只需要3次查找，就能定位到元素33了。</p>
<p>当数据量很大时，跳表的查找复杂度就是O(logN)。</p>
<h2 id="数据结构的时间复杂度"><a href="#数据结构的时间复杂度" class="headerlink" title="数据结构的时间复杂度"></a>数据结构的时间复杂度</h2><table>
<thead>
<tr>
<th>名称</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody><tr>
<td>哈希表</td>
<td>O(1)</td>
</tr>
<tr>
<td>跳表</td>
<td>O(logN)</td>
</tr>
<tr>
<td>双向链表</td>
<td>O(N)</td>
</tr>
<tr>
<td>压缩列表</td>
<td>O(N)</td>
</tr>
<tr>
<td>整数数组</td>
<td>O(N)</td>
</tr>
</tbody></table>
<h2 id="不同操作的复杂度"><a href="#不同操作的复杂度" class="headerlink" title="不同操作的复杂度"></a>不同操作的复杂度</h2><ul>
<li><strong>单元素操作，是指每一种集合类型对单个数据实现的增删改查操作</strong>。这些操作的复杂度由集合采用的数据结构决定，例如，HGET、HSET和HDEL是对哈希表做操作，所以它们的复杂度都是O(1)；Set类型用哈希表作为底层数据结构时，它的SADD、SREM、SRANDMEMBER复杂度也是O(1)。</li>
<li><strong>范围操作，是指集合类型中的遍历操作，可以返回集合中的所有数据,或者返回一个范围内的部分数据。</strong>这类操作的复杂度一般是O(N)，比较耗时，我们应该尽量避免。</li>
<li><strong>统计操作，是指集合类型对集合中所有元素个数的记录</strong>。例如LLEN和SCARD。这类操作复杂度只有O(1)，这是因为当集合类型采用压缩列表、双向链表、整数数组这些数据结构时，这些结构中专门记录了元素的个数统计，因此可以高效地完成相关操作。</li>
<li>例外情况，是指某些数据结构的特殊记录，例如<strong>压缩列表和双向链表都会记录表头和表尾的偏移量</strong>。这样一来，对于List类型的LPOP、RPOP、LPUSH、RPUSH这四个操作来说，它们是在列表的头尾增删元素，这就可以通过偏移量直接定位，所以它们的复杂度也只有O(1)，可以实现快速操作。</li>
</ul>
<h1 id="高性能IO模型：为什么单线程Redis能那么快？"><a href="#高性能IO模型：为什么单线程Redis能那么快？" class="headerlink" title="高性能IO模型：为什么单线程Redis能那么快？"></a>高性能IO模型：为什么单线程Redis能那么快？</h1><p>首先，我们需要明确一点：Redis是单线程，主要是指<strong>Redis的网络IO和键值对读写是由一个线程来完成的，这也是Redis对外提供键值存储服务的主要流程</strong>。但Redis的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的。</p>
<h2 id="为啥用单线程？"><a href="#为啥用单线程？" class="headerlink" title="为啥用单线程？"></a>为啥用单线程？</h2><p><strong>多线程的开销</strong>：</p>
<p>我们刚开始增加线程数时，系统吞吐率会增加，但是，再进一步增加线程时，系统吞吐率就增长迟缓了，有时甚至还会出现下降的情况。</p>
<p>原因在于：解决多线程带来的共享资源的并发访问问题会产生额外的开销。</p>
<p>除此之外，采用多线程开发一般会引入同步原语来保护共享资源的并发访问，这也会降低系统代码的易调试性和可维护性。为了避免这些问题，Redis直接采用了单线程模式。</p>
<h2 id="Redis基于多路复用的高性能I-x2F-O模型"><a href="#Redis基于多路复用的高性能I-x2F-O模型" class="headerlink" title="Redis基于多路复用的高性能I&#x2F;O模型"></a>Redis基于多路复用的高性能I&#x2F;O模型</h2><blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://juejin.cn/post/7049148028875178020">https://juejin.cn/post/7049148028875178020</a></p>
</blockquote>
<p>Linux中的IO多路复用机制是指一个线程处理多个IO流，<strong>该机制允许内核中，同时存在多个监听套接字和已连接套接字</strong>。内核会一直监听这些套接字上的连接请求或数据请求。一旦有请求到达，就会交给Redis线程处理，这就实现了一个Redis线程处理多个IO流的效果。</p>
<p>select&#x2F;epoll一旦监测到FD上有请求到达时，就会触发相应的事件。这些事件会被放进一个事件队列，Redis单线程对该事件队列不断进行处理。这样一来，Redis无需一直轮询是否有请求实际发生，这就可以避免造成CPU资源浪费。同时，Redis在对事件队列中的事件进行处理时，会调用相应的处理函数，这就实现了基于事件的回调。因为Redis一直在对事件队列进行处理，所以能及时响应客户端请求，提升Redis的响应性能。如图所示。</p>
<img src="/2022/06/28/Getting-to-know-redis/redis_io_multiplex.png" class="">

<h1 id="AOF日志-amp-RDB快照：宕机了，Redis如何避免数据丢失，如何实现数据恢复？"><a href="#AOF日志-amp-RDB快照：宕机了，Redis如何避免数据丢失，如何实现数据恢复？" class="headerlink" title="AOF日志&amp;RDB快照：宕机了，Redis如何避免数据丢失，如何实现数据恢复？"></a>AOF日志&amp;RDB快照：宕机了，Redis如何避免数据丢失，如何实现数据恢复？</h1><p>由于Redis将数据存储在内存中，那面临了一个问题：<strong>一旦服务器宕机，内存中的数据将全部丢失。</strong></p>
<p>目前，Redis的持久化主要有两大机制，即AOF日志和RDB快照。</p>
<h2 id="AOF-Append-Only-File-日志"><a href="#AOF-Append-Only-File-日志" class="headerlink" title="AOF(Append Only File)日志"></a>AOF(Append Only File)日志</h2><h3 id="为何采用“写后日志”？"><a href="#为何采用“写后日志”？" class="headerlink" title="为何采用“写后日志”？"></a>为何采用“写后日志”？</h3><p>AOF日志：“写后日志“。Redis先执行命令，把数据写入内存，然后才记录日志。</p>
<p>问题：为何使用“写后日志“？</p>
<p>答：为了避免额外的检查开销，Redis在向AOF里面记录日志的时候，并不会先去对AOF日志命令进行语法检查。”写后日志“避免出现记录错误命令的情况。</p>
<h3 id="三种写回策略"><a href="#三种写回策略" class="headerlink" title="三种写回策略"></a>三种写回策略</h3><p>AOF的两个潜在风险：</p>
<ul>
<li>命令丢失导致无法恢复数据。如果刚执行完一个命令，还没有来得及记日志就宕机了，那么这个命令和相应的数据就有丢失的风险。</li>
<li>阻塞后续操作。AOF日志也是在主线程中执行的，如果在把日志文件写入磁盘时，磁盘写压力大，就会导致写盘很慢，进而导致后续的操作也无法执行了。</li>
</ul>
<p>因此AOF有三种写回策略：</p>
<ul>
<li><strong>Always</strong>，同步写回：每个写命令执行完，立马同步地将日志写回磁盘；</li>
<li><strong>Everysec</strong>，每秒写回：每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；</li>
<li><strong>No</strong>，操作系统控制的写回：每个写命令执行完，只是先把日志写到AOF文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。</li>
</ul>
<table>
<thead>
<tr>
<th>配置项</th>
<th>写回时机</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>Always</td>
<td>同步写回</td>
<td>可靠性高，数据基本不丢失</td>
<td>每个写命令都要落盘，性能影响较大</td>
</tr>
<tr>
<td>EverySec</td>
<td>每秒写回</td>
<td>性能适中</td>
<td>宕机时丢失1秒内的数据</td>
</tr>
<tr>
<td>No</td>
<td>操作系统控制的写回</td>
<td>性能好</td>
<td>宕机时丢失数据较多</td>
</tr>
</tbody></table>
<h3 id="AOF文件过大带来的问题与解决方案"><a href="#AOF文件过大带来的问题与解决方案" class="headerlink" title="AOF文件过大带来的问题与解决方案"></a>AOF文件过大带来的问题与解决方案</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>随着接收的写命令越来越多，AOF文件会越来越大，会带来以下的问题：</p>
<ul>
<li>文件系统本身对文件大小有限制，无法保存过大的文件</li>
<li>如果文件太大，之后再往里面追加命令记录的话，效率也会变低</li>
<li>如果发生宕机，AOF中记录的命令要一个个被重新执行，用于故障恢复，如果日志文件太大，整个恢复过程就会非常缓慢，这就会影响到Redis的正常使用。</li>
</ul>
<h4 id="AOF重写机制"><a href="#AOF重写机制" class="headerlink" title="AOF重写机制"></a>AOF重写机制</h4><p>为解决这个问题，AOF有个重写机制：读取目前数据库中的所有键值对，然后对每一个键值对用一条命令记录它的写入。比如说，当读取了键值对“testkey”: “testvalue”之后，重写机制会记录set testkey testvalue这条命令。这样，当需要恢复时，可以重新执行该命令，实现“testkey”: “testvalue”的写入。</p>
<h4 id="AOF重写会阻塞主线程吗？"><a href="#AOF重写会阻塞主线程吗？" class="headerlink" title="AOF重写会阻塞主线程吗？"></a>AOF重写会阻塞主线程吗？</h4><p>和AOF日志由主线程写回不同，重写过程是由后台线程bgrewriteaof来完成的，这也是为了避免阻塞主线程，导致数据库性能下降。</p>
<p>重写的步骤：</p>
<ul>
<li>每次执行重写时，主线程fork出后台的bgrewriteaof子进程。此时，fork会把主线程的内存拷贝一份给bgrewriteaof子进程，这里面就包含了数据库的最新数据。然后，bgrewriteaof子进程就可以在不影响主线程的情况下，逐一把拷贝的数据写成操作，记入重写日志。</li>
<li>如果有写操作，Redis不仅会把这个操作写到正在使用的AOF日志的缓冲区，还会把这个日志写到AOF重写日志的缓冲区。</li>
</ul>
<p>如图所示：</p>
<img src="/2022/06/28/Getting-to-know-redis/aof_rewrite.png" class="">

<p>总结：每次AOF重写时，Redis会先执行一个内存拷贝，用于重写；然后，使用两个日志保证在重写过程中，新写入的数据不会丢失。而且，因为Redis采用额外的线程进行数据重写，所以，这个过程并不会阻塞主线程。</p>
<h2 id="RDB-Redis-DataBase-快照"><a href="#RDB-Redis-DataBase-快照" class="headerlink" title="RDB(Redis DataBase)快照"></a>RDB(Redis DataBase)快照</h2><p>用AOF方法进行故障恢复的时候，需要逐一把操作日志都执行一遍。如果操作日志非常多，Redis就会恢复得很缓慢，影响到正常使用。因此有另一种持久化方法：RDB快照。</p>
<p>RDB（Redis DataBase）：内存快照，记录内存中的数据在某一个时刻的状态。</p>
<p>需要考虑的问题有：</p>
<ul>
<li>对哪些数据做快照？这关系到快照的执行效率问题；</li>
<li>做快照时，数据还能被增删改吗？这关系到Redis是否被阻塞，能否同时正常处理请求。</li>
</ul>
<h3 id="要给哪些数据做快照？"><a href="#要给哪些数据做快照？" class="headerlink" title="要给哪些数据做快照？"></a>要给哪些数据做快照？</h3><p>Redis的数据都在内存中，为了提供所有数据的可靠性保证，它执行的是<strong>全量快照</strong>，也就是说，把内存中的所有数据都记录到磁盘中。</p>
<p>由于全量数据量会很大，因此我们需要考虑的一个问题是：<strong>快照是否会阻塞主线程。</strong></p>
<p>Redis提供了两个命令来生成RDB文件，分别是save和bgsave。</p>
<ul>
<li>save：在主线程中执行，会导致阻塞；</li>
<li>bgsave：创建一个子进程，专门用于写入RDB文件，避免了主线程的阻塞，这也是Redis RDB文件生成的默认配置。</li>
</ul>
<p>我们可以使用bgsave来执行全量快照，这既提供了数据的可靠性保证，也避免了对Redis的性能影响。</p>
<h3 id="快照时能修改数据吗？"><a href="#快照时能修改数据吗？" class="headerlink" title="快照时能修改数据吗？"></a>快照时能修改数据吗？</h3><p>由于全量数据可能比较大，做完快照所需要的时间可能比较长，在这个时间间隔内，如果内存数据被进行了修改，快照的正确性就得不到保证；如果内存数据不允许被修改，也就是Redis这段期间无法提供写服务，也会给业务服务造成影响。</p>
<p>为了在执行快照的时候让redis也能执行写操作，<strong>Redis借助了操作系统提供的写时复制技术（Copy-On-Write, COW），在执行快照的同时，正常处理写操作。</strong></p>
<p>bgsave子进程是由主线程fork生成的，可以共享主线程的所有内存数据。bgsave子进程运行后，开始读取主线程的内存数据，并把它们写入RDB文件。如果主线程对这些数据也都是读操作（例如图中的键值对A），那么，主线程和bgsave子进程相互不影响。但是，如果主线程要修改一块数据（例如图中的键值对C），那么，这块数据就会被复制一份，生成该数据的副本。然后，bgsave子进程会把这个副本数据写入RDB文件，而在这个过程中，主线程仍然可以直接修改原来的数据。</p>
<p>如图所示：</p>
<img src="/2022/06/28/Getting-to-know-redis/rdb_write.png" class="">

<h3 id="多久做一次快照？"><a href="#多久做一次快照？" class="headerlink" title="多久做一次快照？"></a>多久做一次快照？</h3><p>假设全量快照执行的时间间隔过长，在间隔内，如果机器宕机了，那恢复后的数据可能不是最新的（即，在间隔内修改的数据因为没有快照记录而无法恢复）。</p>
<p>如果全量快照执行的时间间过短，也会带来两方面的开销：</p>
<ul>
<li>频繁将全量数据写入磁盘，会给磁盘带来很大压力，多个快照竞争有限的磁盘带宽，前一个快照还没有做完，后一个又开始做了，容易造成恶性循环。</li>
<li>bgsave子进程需要通过fork操作从主线程创建出来。虽然，子进程在创建后不会再阻塞主线程，但是，fork这个创建过程本身会阻塞主线程，而且主线程的内存越大，阻塞时间越长。如果频繁fork出bgsave子进程，这就会频繁阻塞主线程了。</li>
</ul>
<p>解决方案：可以做增量快照。在第一次做完全量快照后，后续时刻如果再做快照，我们只需要将被修改的数据写入快照文件就行。</p>
<p>如何记录被修改的数据？可以使用使用额外的元数据信息去记录哪些数据被修改了，但这会带来额外的空间开销问题。<strong>“记录哪些数据被修改了”这个思路和AOF就很类似。</strong></p>
<p>Redis 4.0中提出了一个<strong>混合使用AOF日志和内存快照</strong>的方法。简单来说，内存快照以一定的频率执行，在两次快照之间，使用AOF日志记录这期间的所有命令操作。</p>
<p>这样一来，快照不用很频繁地执行，这就避免了频繁fork对主线程的影响。而且，AOF日志也只用记录两次快照间的操作，也就是说，不需要记录所有操作了，因此，就不会出现文件过大的情况了，也可以避免重写开销。</p>
<p>如图所示：</p>
<img src="/2022/06/28/Getting-to-know-redis/aof_cooperate_with_rdb.png" class="">

<h1 id="数据同步：主从库如何实现数据一致？"><a href="#数据同步：主从库如何实现数据一致？" class="headerlink" title="数据同步：主从库如何实现数据一致？"></a>数据同步：主从库如何实现数据一致？</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>尽管AOF和RDB可以在Redis宕机后恢复数据，但假设我们在使用过程中只运行了一个Redis实例，那么该实例在宕机期间，是无法服务新来的数据存取请求的。</p>
<p>Redis具有高可靠性表现在：</p>
<ul>
<li><strong>数据尽量少丢失</strong>。AOF和RDB保证了这一点。</li>
<li><strong>服务尽量少中断</strong>。实现方案是，<strong>增加副本冗余量</strong>，将一份数据同时保存在多个实例上。即使有一个实例出现了故障，需要过一段时间才能恢复，其他实例也可以对外提供服务，不会影响业务使用。</li>
</ul>
<h2 id="主从库模式介绍"><a href="#主从库模式介绍" class="headerlink" title="主从库模式介绍"></a>主从库模式介绍</h2><p>Redis提供了主从库模式，以保证数据副本的一致，主从库之间采用的是读写分离的方式：</p>
<ul>
<li><strong>读操作</strong>：主库、从库都可以接收；</li>
<li><strong>写操作</strong>：首先到主库执行，然后，主库将写操作同步给从库。</li>
</ul>
<h2 id="主从库数据同步的原理"><a href="#主从库数据同步的原理" class="headerlink" title="主从库数据同步的原理"></a>主从库数据同步的原理</h2><h3 id="同步的步骤"><a href="#同步的步骤" class="headerlink" title="同步的步骤"></a>同步的步骤</h3><p>当我们启动多个Redis实例的时候，它们相互之间就可以通过replicaof（Redis 5.0之前使用slaveof）命令形成主库和从库的关系，之后会按照三个阶段完成数据的第一次同步：</p>
<ul>
<li><strong>从库和主库建立连接，并告诉主库即将进行同步，主库确认回复后，主从库间就可以开始同步了</strong>。</li>
<li><strong>主库将所有数据同步给从库。从库收到数据后，在本地完成数据加载</strong>。</li>
<li>主库会把第二阶段执行过程中新收到的写命令，再发送给从库。</li>
</ul>
<p>举例而言，如图所示：</p>
<img src="/2022/06/28/Getting-to-know-redis/master_slave_sync.png" class="">

<p>第一步：从库发送psync命令，表示要进行数据同步，主库根据这个命令的参数来启动复制。psync命令包含了<strong>主库的runID</strong>（redis实例的唯一标识符）和<strong>复制进度offset</strong>（-1表示第一次复制）两个参数。</p>
<p>主库收到psync命令后，会用FULLRESYNC（<strong>表示第一次复制采用的全量复制</strong>）响应命令带上两个参数：主库runID和主库目前的复制进度offset，返回给从库。从库收到响应后，会记录下这两个参数。</p>
<p>第二步：主库执行bgsave命令，生成RDB文件，接着将文件发给从库。从库接收到RDB文件后，会先清空当前数据库，然后加载RDB文件。</p>
<p>在主库将数据同步给从库的过程中，主库不会被阻塞，仍然可以正常接收请求。但是，这些请求中的写操作并没有记录到刚刚生成的RDB文件中。为了保证主从库的数据一致性，主库会在内存中用专门的replication buffer，记录RDB文件生成后收到的所有写操作。</p>
<p>第三步：当主库完成RDB文件发送后，就会把此时replication buffer中的修改操作发给从库，从库再重新执行这些操作。这样一来，主从库就实现同步了。</p>
<h3 id="主从级联"><a href="#主从级联" class="headerlink" title="主从级联"></a>主从级联</h3><p>一次全量复制中，对于主库来说，需要完成两个耗时的操作：生成RDB文件和传输RDB文件。如果从库数量很多，而且都要和主库进行全量复制的话，就会产生以下两个问题：</p>
<ul>
<li>多次fork，会阻塞主线程处理正常请求，从而导致主库响应应用程序的请求速度变慢。</li>
<li>传输RDB文件也会占用主库的网络带宽，同样会给主库的资源使用带来压力。</li>
</ul>
<p>解决方案是：<strong>通过“主-从-从”模式将主库生成RDB和传输RDB的压力，以级联的方式分散到从库上</strong>。</p>
<p>如图所示：</p>
<img src="/2022/06/28/Getting-to-know-redis/cascade.png" class="">

<p><strong>一旦主从库完成了全量复制，它们之间就会一直维护一个网络连接，主库会通过这个连接将后续陆续收到的命令操作再同步给从库</strong>，这个过程也称为<strong>基于长连接的命令传播</strong>，可以避免频繁建立连接的开销。</p>
<p>注意：第一次同步，全量复制是无法避免的，因此<strong>一个Redis实例的数据库不要太大</strong>，一个实例大小在几GB级别比较合适，这样可以减少RDB文件生成、传输和重新加载的开销。</p>
<h3 id="主从库断网了该怎么办？"><a href="#主从库断网了该怎么办？" class="headerlink" title="主从库断网了该怎么办？"></a>主从库断网了该怎么办？</h3><p>当主从库断连后，主库会把断连期间收到的写操作命令，写入replication buffer，同时也会把这些操作命令也写入repl_backlog_buffer这个缓冲区。repl_backlog_buffer是一个<strong>环形缓冲区</strong>，<strong>主库会记录自己写到的位置，从库则会记录自己已经读到的位置</strong>。需要注意的一点是，如果从库的读取速度比较慢，就有可能导致从库还未读取的操作被主库新写的操作覆盖了，这会导致主从库间的数据不一致。（可以通过调整<strong>repl_backlog_size</strong>这个参数来降低这种风险）</p>
<p>主从库的连接恢复之后，从库首先会给主库发送psync命令，并把自己当前的slave_repl_offset发给主库，主库会判断自己的master_repl_offset和slave_repl_offset之间的差距。在网络断连阶段，主库可能会收到新的写操作命令，所以，一般来说，master_repl_offset会大于slave_repl_offset。此时，主库只用把master_repl_offset和slave_repl_offset之间的命令操作同步给从库就行。</p>
<p>如图所示：</p>
<img src="/2022/06/28/Getting-to-know-redis/network_off_solution.png" class="">

<h1 id="哨兵机制-amp-哨兵集群：主库挂了，如何不间断服务？哨兵挂了，主从库怎么切？"><a href="#哨兵机制-amp-哨兵集群：主库挂了，如何不间断服务？哨兵挂了，主从库怎么切？" class="headerlink" title="哨兵机制&amp;哨兵集群：主库挂了，如何不间断服务？哨兵挂了，主从库怎么切？"></a>哨兵机制&amp;哨兵集群：主库挂了，如何不间断服务？哨兵挂了，主从库怎么切？</h1><h2 id="哨兵机制"><a href="#哨兵机制" class="headerlink" title="哨兵机制"></a>哨兵机制</h2><p>如果主库挂了，我们就需要运行一个新主库，比如说把一个从库切换为主库，把它当成主库。这就涉及到三个问题：</p>
<ul>
<li>如何判断主库是真挂了？</li>
<li>该选择哪个从库作为主库？</li>
<li>怎么把新主库的相关信息通知给从库和客户端呢？</li>
</ul>
<h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><p>哨兵其实就是一个运行在特殊模式下的Redis进程，主从库实例运行的同时，它也在运行。哨兵主要负责的就是三个任务：监控、选主（选择主库）和通知。</p>
<ul>
<li>监控：哨兵进程在运行时，周期性地给所有的主从库发送PING命令，检测它们是否仍然在线运行。如果某库没有在规定时间内响应哨兵的PING命令，哨兵就会把它标记为“主观下线”状态。</li>
<li>选主：主库挂了以后，哨兵就需要从很多个从库里，按照一定的规则选择一个从库实例，把它作为新的主库。</li>
<li>通知：在执行通知任务时，哨兵会把新主库的连接信息发给其他从库，让它们执行replicaof命令，和新主库建立连接，并进行数据复制。同时，哨兵会把新主库的连接信息通知给客户端，让它们把请求操作发到新主库上。</li>
</ul>
<h3 id="判定下线"><a href="#判定下线" class="headerlink" title="判定下线"></a>判定下线</h3><p>哨兵可能会对某库的在线状态产生误判。如果哨兵对主库的下线状态产生误判了，启动了主从切换，后续的选主和通知操作都会带来额外的计算和通信开销。</p>
<p>误判一般会发生在集群网络压力较大、网络拥塞，或者是主库本身压力较大的情况下。</p>
<p>为了减小误判率，<strong>通常会采用多实例组成的集群模式进行部署，这也被称为哨兵集群</strong>，由哨兵集群一起决策某库是否下线。当大多数的哨兵实例都判断主库已经“主观下线”了，主库才会被标记为“客观下线”。（少数服从多数）</p>
<h3 id="选定新主库"><a href="#选定新主库" class="headerlink" title="选定新主库"></a>选定新主库</h3><p>哨兵选择新主库的过程可以被称为“筛选+打分”：</p>
<ul>
<li>先按照<strong>一定的筛选条件</strong>，把不符合条件的从库去掉。</li>
<li>然后，我们再按照<strong>一定的规则</strong>，给剩下的从库逐个打分，将得分最高的从库选为新主库。</li>
</ul>
<p>筛选的条件：该从库在线，切网络连接状态稳定。</p>
<p>打分规则可以分为三轮，<strong>只要在某一轮中，有从库得分最高，那么它就是主库了，选主过程到此结束。</strong>如果没有出现得分最高的从库，那么就继续进行下一轮。这三个轮规则分别是：</p>
<ul>
<li><strong>优先级最高的从库得分高。</strong>用户可以通过slave-priority配置项，给不同的从库设置不同优先级。用户可以手动给内存大的实例设置一个高优先级。</li>
<li><strong>和旧主库同步程度最接近的从库得分高。</strong>如果在所有从库中，有从库的slave_repl_offset最接近master_repl_offset，那么它的得分就最高，可以作为新主库。</li>
<li><strong>ID号（实例唯一标识符）小的从库得分高。</strong></li>
</ul>
<h2 id="哨兵集群"><a href="#哨兵集群" class="headerlink" title="哨兵集群"></a>哨兵集群</h2><p>如果有哨兵实例在运行时发生了故障，主从库还能正常切换吗？</p>
<p>一旦多个实例组成了<strong>哨兵集群</strong>，即使有哨兵实例出现故障挂掉了，其他哨兵还能继续协作完成主从库切换的工作。</p>
<h3 id="基于pub-x2F-sub机制的哨兵集群组成"><a href="#基于pub-x2F-sub机制的哨兵集群组成" class="headerlink" title="基于pub&#x2F;sub机制的哨兵集群组成"></a>基于pub&#x2F;sub机制的哨兵集群组成</h3><p>在配置哨兵的信息时，我们只需要设置主库的IP和端口，并没有配置其他哨兵的连接信息。<strong>哨兵实例如何知道彼此的地址？</strong></p>
<p>哨兵只要和主库建立起了连接，就可以在主库上发布消息了，比如说发布它自己的连接信息（IP和端口）。同时，它也可以从主库上订阅消息，获得其他哨兵发布的连接信息。当多个哨兵实例都在主库上做了发布和订阅操作后，它们之间就能知道彼此的IP地址和端口。</p>
<p><strong>哨兵是如何知道从库的IP地址和端口的呢？</strong></p>
<p>哨兵向主库发送INFO命令来完成的。哨兵给主库发送INFO命令，主库接受到这个命令后，就会把从库列表返回给哨兵。接着，哨兵就可以根据从库列表中的连接信息，和每个从库建立连接，并在这个连接上持续地对从库进行监控。</p>
<h3 id="基于pub-x2F-sub机制的客户端事件通知"><a href="#基于pub-x2F-sub机制的客户端事件通知" class="headerlink" title="基于pub&#x2F;sub机制的客户端事件通知"></a>基于pub&#x2F;sub机制的客户端事件通知</h3><p>在“哨兵机制”这一节中，还有个问题没有解决：<strong>客户端如何得知主从切换的过程呢？</strong></p>
<p>从本质上说，哨兵就是一个运行在特定模式下的Redis实例，只不过它并不服务请求操作，只是完成监控、选主和通知的任务。所以，每个哨兵实例也提供pub&#x2F;sub机制，客户端可以从哨兵订阅消息。哨兵提供的消息订阅频道有很多，不同频道包含了主从库切换过程中的不同关键事件。</p>
<p>客户端读取哨兵的配置文件后，可以获得哨兵的地址和端口，和哨兵建立网络连接。然后，我们可以在客户端执行订阅命令，来获取不同的事件消息。</p>
<h3 id="由哪个哨兵执行主从切换？"><a href="#由哪个哨兵执行主从切换？" class="headerlink" title="由哪个哨兵执行主从切换？"></a>由哪个哨兵执行主从切换？</h3><p>首先，先介绍一下“客观下线”的判断过程：</p>
<ul>
<li>任何一个实例只要自身判断主库“主观下线”后，就会给其他实例发送is-master-down-by-addr命令。接着，其他实例会根据自己和主库的连接情况，做出Y或N的响应，Y相当于赞成票，N相当于反对票。</li>
<li>一个哨兵获得了仲裁所需的赞成票数后，就可以标记主库为“客观下线”。这个所需的赞成票数是通过哨兵配置文件中的quorum配置项设定的。</li>
<li>此时，这个哨兵就可以再给其他哨兵发送命令，表明希望由自己来执行主从切换，并让所有其他哨兵进行投票。这个投票过程称为“Leader选举”。因为最终执行主从切换的哨兵称为Leader，投票过程就是确定Leader。</li>
</ul>
<p>在投票过程中，任何一个想成为Leader的哨兵，要满足两个条件：第一，拿到半数以上的赞成票；第二，拿到的票数同时还需要大于等于哨兵配置文件中的quorum值。</p>
<p>如果一轮投票没有产生Leader，哨兵集群会等待一段时间（也就是哨兵故障转移超时时间的2倍），再重新选举。哨兵集群能够进行成功投票，很大程度上依赖于选举命令的正常网络传播。如果网络压力较大或有短时堵塞，就可能导致没有一个哨兵能拿到半数以上的赞成票。所以，等到网络拥塞好转之后，再进行投票选举，成功的概率就会增加。</p>
<p>注意：最好保证所有哨兵实例的配置是一致的，尤其是主观下线的判断值down-after-milliseconds。否则，可能哨兵集群一直没有对有故障的主库形成共识，也就没有及时切换主库，最终的结果就是集群服务不稳定。</p>
<h1 id="切片集群：数据增多了，是该加内存还是加实例？"><a href="#切片集群：数据增多了，是该加内存还是加实例？" class="headerlink" title="切片集群：数据增多了，是该加内存还是加实例？"></a>切片集群：数据增多了，是该加内存还是加实例？</h1><h2 id="如何保存更多数据？"><a href="#如何保存更多数据？" class="headerlink" title="如何保存更多数据？"></a>如何保存更多数据？</h2><p>有两种方案：纵向扩展（scale up）和横向扩展（scale out）：</p>
<ul>
<li><strong>纵向扩展</strong>：升级单个Redis实例的资源配置，包括增加内存容量、增加磁盘容量、使用更高配置的CPU。<ul>
<li>优点：<strong>实施起来简单、直接</strong>。</li>
<li>缺点：纵向扩展会受到硬件和成本的限制。除此之外，当使用RDB对数据进行持久化时，如果数据量增加，需要的内存也会增加，主线程fork子进程时就可能会阻塞。</li>
</ul>
</li>
<li><strong>横向扩展</strong>：横向增加当前Redis实例的个数。<ul>
<li>优点：不用担心单个实例的硬件和成本限制。<strong>在面向百万、千万级别的用户规模时，横向扩展的Redis切片集群会是一个非常好的选择</strong>。</li>
</ul>
</li>
</ul>
<p>但切片集群面临着这样的问题：</p>
<ul>
<li>数据切片后，在多个实例之间如何分布？</li>
<li>客户端怎么确定想要访问的数据在哪个实例上？</li>
</ul>
<h2 id="数据切片和实例的对应分布关系"><a href="#数据切片和实例的对应分布关系" class="headerlink" title="数据切片和实例的对应分布关系"></a>数据切片和实例的对应分布关系</h2><p>Redis Cluster方案采用哈希槽（Hash Slot），来处理数据和实例之间的映射关系。在Redis Cluster方案中，一个切片集群共有16384个哈希槽，这些哈希槽类似于数据分区，每个键值对都会根据它的key，被映射到一个哈希槽中。我们在部署Redis Cluster方案时，可以使用cluster create命令创建集群，此时，Redis会自动把这些槽平均分布在集群实例上。例如，如果集群中有N个实例，那么，每个实例上的槽个数为16384&#x2F;N个。我们也可以使用cluster meet命令手动建立实例间的连接，形成集群，再使用cluster addslots命令，指定每个实例上的哈希槽个数。</p>
<h2 id="客户端如何定位数据？"><a href="#客户端如何定位数据？" class="headerlink" title="客户端如何定位数据？"></a>客户端如何定位数据？</h2><p>一般来说，客户端和集群实例建立连接后，实例就会把哈希槽的分配信息发给客户端。但是，在集群刚刚创建的时候，每个实例只知道自己被分配了哪些哈希槽，是不知道其他实例拥有的哈希槽信息的。Redis实例会把自己的哈希槽信息发给和它相连接的其它实例，来完成哈希槽分配信息的扩散。当实例之间相互连接后，每个实例就有所有哈希槽的映射关系了。客户端收到哈希槽信息后，会把哈希槽信息缓存在本地。当客户端请求键值对时，会先计算键所对应的哈希槽，然后就可以给相应的实例发送请求了。</p>
<p>但是，在集群中，实例和哈希槽的对应关系并不是一成不变的，最常见的变化有两个：</p>
<ul>
<li>在集群中，实例有新增或删除，Redis需要重新分配哈希槽；</li>
<li>为了负载均衡，Redis需要把哈希槽在所有实例上重新分布一遍。</li>
</ul>
<p>Redis Cluster方案提供了一种<strong>重定向机制，</strong>所谓的“重定向”，就是指，客户端给一个实例发送数据读写操作时，这个实例上并没有相应的数据，那么，这个实例就会给客户端返回MOVED命令响应结果，这个结果中就包含了新实例的访问地址，客户端接着再给一个新实例发送操作请求。</p>
<p>假设数据还没有迁移完毕，客户端就发送了请求，则不会返回MOVED响应结果。举例说明，Slot 2正在从实例2往实例3迁移，key1和key2已经迁移过去，key3和key4还在实例2。客户端向实例2请求key2后，就会收到实例2返回的ASK命令。ASK命令表示两层含义：第一，表明Slot数据还在迁移中；第二，ASK命令把客户端所请求数据的最新实例地址返回给客户端，此时，客户端需要给实例3发送ASKING命令，然后再发送操作命令。</p>
<p>和MOVED命令不同，<strong>ASK命令并不会更新客户端缓存的哈希槽分配信息</strong>。</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/05/13/HTTP/" rel="prev" title="关于HTTP不可不说的那些事">
      <i class="fa fa-chevron-left"></i> 关于HTTP不可不说的那些事
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/07/09/what-happens-after-opening-the-url/" rel="next" title="输入url后发生了什么">
      输入url后发生了什么 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84%EF%BC%9A%E4%B8%80%E4%B8%AA%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8C%85%E5%90%AB%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">2.</span> <span class="nav-text">基本架构：一个键值数据库包含什么？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%98%E4%BB%80%E4%B9%88%E6%95%B0%E6%8D%AE-amp-%E5%81%9A%E4%BB%80%E4%B9%88%E6%93%8D%E4%BD%9C"><span class="nav-number">2.1.</span> <span class="nav-text">存什么数据 &amp; 做什么操作</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%98%E4%BB%80%E4%B9%88%E6%95%B0%E6%8D%AE"><span class="nav-number">2.1.1.</span> <span class="nav-text">存什么数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%81%9A%E4%BB%80%E4%B9%88%E6%93%8D%E4%BD%9C"><span class="nav-number">2.1.2.</span> <span class="nav-text">做什么操作</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%AE%E5%80%BC%E5%AF%B9%E4%BF%9D%E5%AD%98%E5%9C%A8%E5%93%AA%EF%BC%9F"><span class="nav-number">2.2.</span> <span class="nav-text">键值对保存在哪？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E9%94%AE%E5%80%BC%E5%AF%B9%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="nav-number">2.3.</span> <span class="nav-text">如何定位键值对的位置</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%87%8D%E5%90%AF%E5%90%8E%E5%BF%AB%E9%80%9F%E6%8F%90%E4%BE%9B%E6%9C%8D%E5%8A%A1"><span class="nav-number">2.4.</span> <span class="nav-text">如何实现重启后快速提供服务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E5%86%85%E9%83%A8%E6%9E%B6%E6%9E%84"><span class="nav-number">2.5.</span> <span class="nav-text">基本内部架构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%8ESimpleKV%E5%88%B0Redis"><span class="nav-number">2.6.</span> <span class="nav-text">从SimpleKV到Redis</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%BF%AB%E9%80%9F%E7%9A%84Redis%E7%94%B1%E5%93%AA%E4%BA%9B%E6%85%A2%E6%93%8D%E4%BD%9C%EF%BC%9F"><span class="nav-number">3.</span> <span class="nav-text">数据结构：快速的Redis由哪些慢操作？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%94%AE%E5%80%BC%E5%AF%B9%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-number">3.1.</span> <span class="nav-text">键值对的结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8%E7%9A%84%E5%86%B2%E7%AA%81%E5%92%8Crehash"><span class="nav-number">3.2.</span> <span class="nav-text">哈希表的冲突和rehash</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%8B%E7%BC%A9%E5%88%97%E8%A1%A8"><span class="nav-number">3.3.</span> <span class="nav-text">压缩列表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%B7%B3%E8%A1%A8"><span class="nav-number">3.4.</span> <span class="nav-text">跳表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">3.5.</span> <span class="nav-text">数据结构的时间复杂度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8D%E5%90%8C%E6%93%8D%E4%BD%9C%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-number">3.6.</span> <span class="nav-text">不同操作的复杂度</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E9%AB%98%E6%80%A7%E8%83%BDIO%E6%A8%A1%E5%9E%8B%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8D%95%E7%BA%BF%E7%A8%8BRedis%E8%83%BD%E9%82%A3%E4%B9%88%E5%BF%AB%EF%BC%9F"><span class="nav-number">4.</span> <span class="nav-text">高性能IO模型：为什么单线程Redis能那么快？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E5%95%A5%E7%94%A8%E5%8D%95%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="nav-number">4.1.</span> <span class="nav-text">为啥用单线程？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Redis%E5%9F%BA%E4%BA%8E%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E9%AB%98%E6%80%A7%E8%83%BDI-x2F-O%E6%A8%A1%E5%9E%8B"><span class="nav-number">4.2.</span> <span class="nav-text">Redis基于多路复用的高性能I&#x2F;O模型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#AOF%E6%97%A5%E5%BF%97-amp-RDB%E5%BF%AB%E7%85%A7%EF%BC%9A%E5%AE%95%E6%9C%BA%E4%BA%86%EF%BC%8CRedis%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%E6%95%B0%E6%8D%AE%E4%B8%A2%E5%A4%B1%EF%BC%8C%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D%EF%BC%9F"><span class="nav-number">5.</span> <span class="nav-text">AOF日志&amp;RDB快照：宕机了，Redis如何避免数据丢失，如何实现数据恢复？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#AOF-Append-Only-File-%E6%97%A5%E5%BF%97"><span class="nav-number">5.1.</span> <span class="nav-text">AOF(Append Only File)日志</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BD%95%E9%87%87%E7%94%A8%E2%80%9C%E5%86%99%E5%90%8E%E6%97%A5%E5%BF%97%E2%80%9D%EF%BC%9F"><span class="nav-number">5.1.1.</span> <span class="nav-text">为何采用“写后日志”？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%89%E7%A7%8D%E5%86%99%E5%9B%9E%E7%AD%96%E7%95%A5"><span class="nav-number">5.1.2.</span> <span class="nav-text">三种写回策略</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AOF%E6%96%87%E4%BB%B6%E8%BF%87%E5%A4%A7%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">5.1.3.</span> <span class="nav-text">AOF文件过大带来的问题与解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%97%AE%E9%A2%98"><span class="nav-number">5.1.3.1.</span> <span class="nav-text">问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AOF%E9%87%8D%E5%86%99%E6%9C%BA%E5%88%B6"><span class="nav-number">5.1.3.2.</span> <span class="nav-text">AOF重写机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#AOF%E9%87%8D%E5%86%99%E4%BC%9A%E9%98%BB%E5%A1%9E%E4%B8%BB%E7%BA%BF%E7%A8%8B%E5%90%97%EF%BC%9F"><span class="nav-number">5.1.3.3.</span> <span class="nav-text">AOF重写会阻塞主线程吗？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RDB-Redis-DataBase-%E5%BF%AB%E7%85%A7"><span class="nav-number">5.2.</span> <span class="nav-text">RDB(Redis DataBase)快照</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A6%81%E7%BB%99%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E5%81%9A%E5%BF%AB%E7%85%A7%EF%BC%9F"><span class="nav-number">5.2.1.</span> <span class="nav-text">要给哪些数据做快照？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BF%AB%E7%85%A7%E6%97%B6%E8%83%BD%E4%BF%AE%E6%94%B9%E6%95%B0%E6%8D%AE%E5%90%97%EF%BC%9F"><span class="nav-number">5.2.2.</span> <span class="nav-text">快照时能修改数据吗？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E4%B9%85%E5%81%9A%E4%B8%80%E6%AC%A1%E5%BF%AB%E7%85%A7%EF%BC%9F"><span class="nav-number">5.2.3.</span> <span class="nav-text">多久做一次快照？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%EF%BC%9A%E4%B8%BB%E4%BB%8E%E5%BA%93%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%EF%BC%9F"><span class="nav-number">6.</span> <span class="nav-text">数据同步：主从库如何实现数据一致？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%83%8C%E6%99%AF"><span class="nav-number">6.1.</span> <span class="nav-text">背景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E5%BA%93%E6%A8%A1%E5%BC%8F%E4%BB%8B%E7%BB%8D"><span class="nav-number">6.2.</span> <span class="nav-text">主从库模式介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E5%BA%93%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-number">6.3.</span> <span class="nav-text">主从库数据同步的原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="nav-number">6.3.1.</span> <span class="nav-text">同步的步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E7%BA%A7%E8%81%94"><span class="nav-number">6.3.2.</span> <span class="nav-text">主从级联</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E4%BB%8E%E5%BA%93%E6%96%AD%E7%BD%91%E4%BA%86%E8%AF%A5%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="nav-number">6.3.3.</span> <span class="nav-text">主从库断网了该怎么办？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6-amp-%E5%93%A8%E5%85%B5%E9%9B%86%E7%BE%A4%EF%BC%9A%E4%B8%BB%E5%BA%93%E6%8C%82%E4%BA%86%EF%BC%8C%E5%A6%82%E4%BD%95%E4%B8%8D%E9%97%B4%E6%96%AD%E6%9C%8D%E5%8A%A1%EF%BC%9F%E5%93%A8%E5%85%B5%E6%8C%82%E4%BA%86%EF%BC%8C%E4%B8%BB%E4%BB%8E%E5%BA%93%E6%80%8E%E4%B9%88%E5%88%87%EF%BC%9F"><span class="nav-number">7.</span> <span class="nav-text">哨兵机制&amp;哨兵集群：主库挂了，如何不间断服务？哨兵挂了，主从库怎么切？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6"><span class="nav-number">7.1.</span> <span class="nav-text">哨兵机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B"><span class="nav-number">7.1.1.</span> <span class="nav-text">基本流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%A4%E5%AE%9A%E4%B8%8B%E7%BA%BF"><span class="nav-number">7.1.2.</span> <span class="nav-text">判定下线</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%89%E5%AE%9A%E6%96%B0%E4%B8%BB%E5%BA%93"><span class="nav-number">7.1.3.</span> <span class="nav-text">选定新主库</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%93%A8%E5%85%B5%E9%9B%86%E7%BE%A4"><span class="nav-number">7.2.</span> <span class="nav-text">哨兵集群</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8Epub-x2F-sub%E6%9C%BA%E5%88%B6%E7%9A%84%E5%93%A8%E5%85%B5%E9%9B%86%E7%BE%A4%E7%BB%84%E6%88%90"><span class="nav-number">7.2.1.</span> <span class="nav-text">基于pub&#x2F;sub机制的哨兵集群组成</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8Epub-x2F-sub%E6%9C%BA%E5%88%B6%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BA%8B%E4%BB%B6%E9%80%9A%E7%9F%A5"><span class="nav-number">7.2.2.</span> <span class="nav-text">基于pub&#x2F;sub机制的客户端事件通知</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%B1%E5%93%AA%E4%B8%AA%E5%93%A8%E5%85%B5%E6%89%A7%E8%A1%8C%E4%B8%BB%E4%BB%8E%E5%88%87%E6%8D%A2%EF%BC%9F"><span class="nav-number">7.2.3.</span> <span class="nav-text">由哪个哨兵执行主从切换？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%88%87%E7%89%87%E9%9B%86%E7%BE%A4%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%A2%9E%E5%A4%9A%E4%BA%86%EF%BC%8C%E6%98%AF%E8%AF%A5%E5%8A%A0%E5%86%85%E5%AD%98%E8%BF%98%E6%98%AF%E5%8A%A0%E5%AE%9E%E4%BE%8B%EF%BC%9F"><span class="nav-number">8.</span> <span class="nav-text">切片集群：数据增多了，是该加内存还是加实例？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E5%AD%98%E6%9B%B4%E5%A4%9A%E6%95%B0%E6%8D%AE%EF%BC%9F"><span class="nav-number">8.1.</span> <span class="nav-text">如何保存更多数据？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E5%88%87%E7%89%87%E5%92%8C%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%AF%B9%E5%BA%94%E5%88%86%E5%B8%83%E5%85%B3%E7%B3%BB"><span class="nav-number">8.2.</span> <span class="nav-text">数据切片和实例的对应分布关系</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E6%95%B0%E6%8D%AE%EF%BC%9F"><span class="nav-number">8.3.</span> <span class="nav-text">客户端如何定位数据？</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Ran"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">Ran</p>
  <div class="site-description" itemprop="description">talk is cheap. 知行合一</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">7</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">2</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/iris-in-my-garden" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;iris-in-my-garden" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Ran</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="Symbols count total">49k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="Reading time total">45 mins.</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
